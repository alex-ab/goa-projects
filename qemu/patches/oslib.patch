--- a/util/oslib-posix.c
+++ b/util/oslib-posix.c
@@ -92,15 +92,36 @@
 static QemuMutex page_mutex;
 static QemuCond page_cond;
 
+/* Genode thread base ABI */
+extern unsigned long _ZN6Genode6Thread23stack_area_virtual_baseEv(void);
+extern unsigned long _ZN6Genode6Thread18stack_virtual_sizeEv(void);
+
 int qemu_get_thread_id(void)
 {
 #if defined(__linux__)
     return syscall(SYS_gettid);
 #elif defined(__FreeBSD__)
+#if 1
+    /* on Genode stacks are max 1M - XXX potential to break unnoticed */
+    int thread_ids_base = _ZN6Genode6Thread23stack_area_virtual_baseEv() /
+                          _ZN6Genode6Thread18stack_virtual_sizeEv();
+    int thread_id_base = ((unsigned long)&thread_ids_base) /
+                         _ZN6Genode6Thread18stack_virtual_sizeEv();
+
+    if (thread_id_base < thread_ids_base || thread_id_base - thread_ids_base >= 256) {
+        perror("qemu_get_thread_id calculation failed");
+        exit(1);
+    }
+
+    printf("%s %d\n", __func__, thread_id_base - thread_ids_base);
+
+    return thread_id_base - thread_ids_base;
+#else
     /* thread id is up to INT_MAX */
     long tid;
     thr_self(&tid);
     return (int)tid;
+#endif
 #elif defined(__NetBSD__)
     return _lwp_self();
 #elif defined(__OpenBSD__)
@@ -635,6 +641,10 @@
     char *name = NULL;
 
 #if defined(__FreeBSD__)
+#if 1
+    perror("qemu_get_pid_name not implemented");
+    exit(1);
+#else
     /* BSDs don't have /proc, but they provide a nice substitute */
     struct kinfo_proc *proc = kinfo_getproc(pid);
 
@@ -642,6 +652,7 @@
 //        name = g_strdup(proc->ki_comm);
         free(proc);
     }
+#endif
 #else
     /* Assume a system with reasonable procfs */
     char *pid_path;
@@ -705,7 +705,7 @@
     /* Stack grows down -- guard page at the bottom. */
     if (mprotect(ptr, pagesz, PROT_NONE) != 0) {
         perror("failed to set up stack guard page");
-        abort();
+        //abort();
     }
 
 #ifdef CONFIG_DEBUG_STACK_USAGE
